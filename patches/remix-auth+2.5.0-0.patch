diff --git a/node_modules/remix-auth/build/strategies/index.js b/node_modules/remix-auth/build/strategies/index.js
index 8fef9eb..7a9c19d 100644
--- a/node_modules/remix-auth/build/strategies/index.js
+++ b/node_modules/remix-auth/build/strategies/index.js
@@ -1,12 +1,12 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
-    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
-}) : (function(o, m, k, k2) {
+    Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
+}) : (function (o, m, k, k2) {
     if (k2 === undefined) k2 = k;
     o[k2] = m[k];
 }));
-var __exportStar = (this && this.__exportStar) || function(m, exports) {
+var __exportStar = (this && this.__exportStar) || function (m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
@@ -15,7 +15,6 @@ __exportStar(require("./basic"), exports);
 __exportStar(require("./custom"), exports);
 __exportStar(require("./github"), exports);
 __exportStar(require("./google"), exports);
-__exportStar(require("./kcd"), exports);
 __exportStar(require("./local"), exports);
 __exportStar(require("./mock"), exports);
 __exportStar(require("./oauth2"), exports);
diff --git a/node_modules/remix-auth/build/strategies/kcd.d.ts b/node_modules/remix-auth/build/strategies/kcd.d.ts
deleted file mode 100644
index 6122d9a..0000000
--- a/node_modules/remix-auth/build/strategies/kcd.d.ts
+++ /dev/null
@@ -1,124 +0,0 @@
-import { SessionStorage } from "@remix-run/server-runtime";
-import { Strategy, StrategyOptions } from "../authenticator";
-export interface KCDSendEmailOptions<User> {
-    emailAddress: string;
-    magicLink: string;
-    user?: User | null;
-    domainUrl: string;
-}
-export interface KCDSendEmailFunction<User> {
-    (options: KCDSendEmailOptions<User>): Promise<void>;
-}
-/**
- * Validate the email address the user is trying to use to login.
- * This can be useful to ensure it's not a disposable email address.
- * @param emailAddress The email address to validate
- */
-export interface KCDVerifyEmailFunction {
-    (email: string): Promise<void>;
-}
-/**
- * The content of the magic link payload
- */
-export interface KCDMagicLinkPayload {
-    /**
-     * The email address used to authenticate
-     */
-    emailAddress: string;
-    /**
-     * Whent the magic link was created, as an ISO string. This is used to check
-     * the email link is still valid.
-     */
-    creationDate: string;
-    /**
-     * If it should be validated or not.
-     */
-    validateSessionMagicLink: boolean;
-}
-export interface KCDStrategyOptions<User> {
-    /**
-     * The endpoint the user will go after clicking on the email link.
-     * A whole URL is not required, the pathname is enough, the strategy will
-     * detect the host of the request and use it to build the URL.
-     * @default "/magic"
-     */
-    callbackURL?: string;
-    /**
-     * A function to send the email. This function should receive the email
-     * address of the user and the URL to redirect to and should return a Promise.
-     * The value of the Promise will be ignored.
-     */
-    sendEmail: KCDSendEmailFunction<User>;
-    /**
-     * A function to validate the email address. This function should receive the
-     * email address as a string and return a Promise. The value of the Promise
-     * will be ignored, in case of error throw an error.
-     *
-     * By default it only test the email agains the RegExp `/.+@.+/`.
-     */
-    verifyEmailAddress?: KCDVerifyEmailFunction;
-    /**
-     * A secret string used to encrypt and decrypt the token and magic link.
-     */
-    secret: string;
-    /**
-     * The name of the form input used to get the email.
-     * @default "email"
-     */
-    emailField?: string;
-    /**
-     * The param name the strategy will use to read the token from the email link.
-     * @default "token"
-     */
-    magicLinkSearchParam?: string;
-    /**
-     * How long the magic link will be valid. Default to 30 minutes.
-     * @default 1_800_000
-     */
-    linkExpirationTime?: number;
-    /**
-     * The key on the session to store any error message.
-     * @default "kcd:error"
-     */
-    sessionErrorKey?: string;
-    /**
-     * The key on the session to store the magic link.
-     * @default "kcd:magicLink"
-     */
-    sessionMagicLinkKey?: string;
-    /**
-     * Add an extra layer of protection and validate the magic link is valid.
-     * @default false
-     */
-    validateSessionMagicLink?: boolean;
-}
-export interface KCDStrategyVerifyCallback<User> {
-    (emailAddress: string): Promise<User>;
-}
-export declare class KCDStrategy<User> implements Strategy<User> {
-    name: string;
-    private verify;
-    private emailField;
-    private callbackURL;
-    private sendEmail;
-    private validateEmail;
-    private secret;
-    private algorithm;
-    private ivLength;
-    private encryptionKey;
-    private magicLinkSearchParam;
-    private linkExpirationTime;
-    private sessionErrorKey;
-    private sessionMagicLinkKey;
-    private validateSessionMagicLink;
-    constructor(options: KCDStrategyOptions<User>, verify: KCDStrategyVerifyCallback<User>);
-    authenticate(request: Request, sessionStorage: SessionStorage, options: StrategyOptions): Promise<User>;
-    private getDomainURL;
-    private createMagicLinkPayload;
-    private getMagicLink;
-    private sendToken;
-    private encrypt;
-    private decrypt;
-    private getMagicLinkCode;
-    private validateMagicLink;
-}
diff --git a/node_modules/remix-auth/build/strategies/kcd.js b/node_modules/remix-auth/build/strategies/kcd.js
deleted file mode 100644
index 1c35106..0000000
--- a/node_modules/remix-auth/build/strategies/kcd.js
+++ /dev/null
@@ -1,215 +0,0 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.KCDStrategy = void 0;
-const crypto_1 = __importDefault(require("crypto"));
-const server_runtime_1 = require("@remix-run/server-runtime");
-let verifyEmailAddress = async (email) => {
-    if (!/.+@.+/.test(email))
-        throw new Error("A valid email is required.");
-};
-class KCDStrategy {
-    constructor(options, verify) {
-        var _a, _b, _c, _d, _e, _f, _g, _h;
-        this.name = "kcd";
-        this.emailField = "email";
-        this.algorithm = "aes-256-ctr";
-        this.ivLength = 16;
-        this.verify = verify;
-        this.sendEmail = options.sendEmail;
-        this.callbackURL = (_a = options.callbackURL) !== null && _a !== void 0 ? _a : "/magic";
-        this.secret = options.secret;
-        this.sessionErrorKey = (_b = options.sessionErrorKey) !== null && _b !== void 0 ? _b : "kcd:error";
-        this.sessionMagicLinkKey = (_c = options.sessionMagicLinkKey) !== null && _c !== void 0 ? _c : "kcd:magiclink";
-        this.validateEmail = (_d = options.verifyEmailAddress) !== null && _d !== void 0 ? _d : verifyEmailAddress;
-        this.emailField = (_e = options.emailField) !== null && _e !== void 0 ? _e : this.emailField;
-        this.magicLinkSearchParam = (_f = options.magicLinkSearchParam) !== null && _f !== void 0 ? _f : "token";
-        this.linkExpirationTime = (_g = options.linkExpirationTime) !== null && _g !== void 0 ? _g : 1000 * 60 * 30; // 30 minutes
-        this.encryptionKey = crypto_1.default.scryptSync(this.secret, "salt", 32);
-        this.validateSessionMagicLink = (_h = options.validateSessionMagicLink) !== null && _h !== void 0 ? _h : false;
-    }
-    async authenticate(request, sessionStorage, options) {
-        var _a;
-        let session = await sessionStorage.getSession(request.headers.get("Cookie"));
-        // This should only be called in an action if it's used to start the login
-        // process
-        if (request.method === "POST") {
-            if (!options.successRedirect) {
-                throw new Error("Missing successRedirect. The successRedirect is required for POST requests.");
-            }
-            // get the email address from the request body
-            let body = new URLSearchParams(await request.text());
-            let emailAddress = body.get(this.emailField);
-            // if it doesn't have an email address,
-            if (!emailAddress) {
-                let message = "Missing email address.";
-                if (!options.failureRedirect)
-                    throw new Error(message);
-                session.flash(this.sessionErrorKey, message);
-                let cookie = await sessionStorage.commitSession(session);
-                throw server_runtime_1.redirect(options.failureRedirect, {
-                    headers: { "Set-Cookie": cookie },
-                });
-            }
-            try {
-                // Validate the email address
-                await this.validateEmail(emailAddress);
-                let domainUrl = this.getDomainURL(request);
-                let magicLink = await this.sendToken(emailAddress, domainUrl);
-                session.set(this.sessionMagicLinkKey, this.encrypt(magicLink));
-                throw server_runtime_1.redirect(options.successRedirect, {
-                    headers: {
-                        "Set-Cookie": await sessionStorage.commitSession(session),
-                    },
-                });
-            }
-            catch (error) {
-                if (!options.failureRedirect)
-                    throw error;
-                let message = error.message;
-                session.flash(this.sessionErrorKey, message);
-                let cookie = await sessionStorage.commitSession(session);
-                throw server_runtime_1.redirect(options.failureRedirect, {
-                    headers: { "Set-Cookie": cookie },
-                });
-            }
-        }
-        let user;
-        try {
-            // If we get here, the user clicked on the magic link inside email
-            let magicLink = (_a = session.get(this.sessionMagicLinkKey)) !== null && _a !== void 0 ? _a : "";
-            let email = this.validateMagicLink(request.url, this.decrypt(magicLink));
-            // now that we have the user email we can call verify to get the user
-            user = await this.verify(email);
-        }
-        catch (error) {
-            // if something happens, we should redirect to the failureRedirect
-            // and flash the error message, or just throw the error if failureRedirect
-            // is not defined
-            if (!options.failureRedirect)
-                throw error;
-            let message = error.message;
-            session.flash(this.sessionErrorKey, message);
-            let cookie = await sessionStorage.commitSession(session);
-            throw server_runtime_1.redirect(options.failureRedirect, {
-                headers: { "Set-Cookie": cookie },
-            });
-        }
-        if (!options.successRedirect)
-            return user;
-        // remove the magic link from the session
-        session.unset(this.sessionMagicLinkKey);
-        session.set(options.sessionKey, user);
-        let cookie = await sessionStorage.commitSession(session);
-        throw server_runtime_1.redirect(options.successRedirect, {
-            headers: { "Set-Cookie": cookie },
-        });
-    }
-    getDomainURL(request) {
-        var _a;
-        let host = (_a = request.headers.get("X-Forwarded-Host")) !== null && _a !== void 0 ? _a : request.headers.get("host");
-        if (!host) {
-            throw new Error("Could not determine domain URL.");
-        }
-        let protocol = host.includes("localhost") ? "http" : "https";
-        return `${protocol}://${host}`;
-    }
-    createMagicLinkPayload(emailAddress) {
-        return {
-            emailAddress,
-            creationDate: new Date().toISOString(),
-            validateSessionMagicLink: this.validateSessionMagicLink,
-        };
-    }
-    getMagicLink(emailAddress, domainUrl) {
-        let payload = this.createMagicLinkPayload(emailAddress);
-        let stringToEncrypt = JSON.stringify(payload);
-        let encryptedString = this.encrypt(stringToEncrypt);
-        let url = new URL(domainUrl);
-        url.pathname = this.callbackURL;
-        url.searchParams.set(this.magicLinkSearchParam, encryptedString);
-        return url.toString();
-    }
-    async sendToken(emailAddress, domainUrl) {
-        let magicLink = this.getMagicLink(emailAddress, domainUrl);
-        let user = await this.verify(emailAddress).catch(() => null);
-        await this.sendEmail({
-            emailAddress,
-            magicLink,
-            user,
-            domainUrl,
-        });
-        return magicLink;
-    }
-    encrypt(text) {
-        let iv = crypto_1.default.randomBytes(this.ivLength);
-        let cipher = crypto_1.default.createCipheriv(this.algorithm, this.encryptionKey, iv);
-        let encrypted = Buffer.concat([cipher.update(text), cipher.final()]);
-        return `${iv.toString("hex")}:${encrypted.toString("hex")}`;
-    }
-    decrypt(text) {
-        let [ivPart, encryptedPart] = text.split(":");
-        if (!ivPart || !encryptedPart) {
-            throw new Error("Invalid text.");
-        }
-        let iv = Buffer.from(ivPart, "hex");
-        let encryptedText = Buffer.from(encryptedPart, "hex");
-        let decipher = crypto_1.default.createDecipheriv(this.algorithm, this.encryptionKey, iv);
-        let decrypted = Buffer.concat([
-            decipher.update(encryptedText),
-            decipher.final(),
-        ]);
-        return decrypted.toString();
-    }
-    getMagicLinkCode(link) {
-        var _a;
-        try {
-            let url = new URL(link);
-            return (_a = url.searchParams.get(this.magicLinkSearchParam)) !== null && _a !== void 0 ? _a : "";
-        }
-        catch {
-            return "";
-        }
-    }
-    validateMagicLink(requestUrl, sessionMagicLink) {
-        let linkCode = this.getMagicLinkCode(requestUrl);
-        let sessionLinkCode = sessionMagicLink
-            ? this.getMagicLinkCode(sessionMagicLink)
-            : null;
-        let emailAddress, linkCreationDateString, validateSessionMagicLink;
-        try {
-            let decryptedString = this.decrypt(linkCode);
-            let payload = JSON.parse(decryptedString);
-            emailAddress = payload.emailAddress;
-            linkCreationDateString = payload.creationDate;
-            validateSessionMagicLink = payload.validateSessionMagicLink;
-        }
-        catch (error) {
-            console.error(error);
-            throw new Error("Sign in link invalid. Please request a new one.");
-        }
-        if (typeof emailAddress !== "string") {
-            throw new TypeError("Sign in link invalid. Please request a new one.");
-        }
-        if (validateSessionMagicLink) {
-            if (!sessionLinkCode) {
-                throw new Error("Sign in link invalid. Please request a new one.");
-            }
-            if (linkCode !== sessionLinkCode) {
-                throw new Error(`You must open the magic link on the same device it was created from for security reasons. Please request a new link.`);
-            }
-        }
-        if (typeof linkCreationDateString !== "string") {
-            throw new TypeError("Sign in link invalid. Please request a new one.");
-        }
-        let linkCreationDate = new Date(linkCreationDateString);
-        let expirationTime = linkCreationDate.getTime() + this.linkExpirationTime;
-        if (Date.now() > expirationTime) {
-            throw new Error("Magic link expired. Please request a new one.");
-        }
-        return emailAddress;
-    }
-}
-exports.KCDStrategy = KCDStrategy;
